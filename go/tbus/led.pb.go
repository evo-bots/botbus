// Code generated by protoc-gen-go.
// source: tbus/led.proto
// DO NOT EDIT!

package tbus

import "time"
import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/golang/protobuf/ptypes/empty"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type LEDPowerState struct {
	On bool `protobuf:"varint,1,opt,name=on" json:"on,omitempty"`
}

func (m *LEDPowerState) Reset()                    { *m = LEDPowerState{} }
func (m *LEDPowerState) String() string            { return proto.CompactTextString(m) }
func (*LEDPowerState) ProtoMessage()               {}
func (*LEDPowerState) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

func init() {
	proto.RegisterType((*LEDPowerState)(nil), "tbus.LEDPowerState")
}

func init() { proto.RegisterFile("tbus/led.proto", fileDescriptor2) }

var fileDescriptor2 = []byte{
	// 169 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xe2, 0xe2, 0x2b, 0x49, 0x2a, 0x2d,
	0xd6, 0xcf, 0x49, 0x4d, 0xd1, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x01, 0xf1, 0xa5, 0xa4,
	0xd3, 0xf3, 0xf3, 0xd3, 0x73, 0x52, 0xf5, 0xc1, 0x62, 0x49, 0xa5, 0x69, 0xfa, 0xa9, 0xb9, 0x05,
	0x25, 0x95, 0x10, 0x25, 0x52, 0x92, 0x60, 0x2d, 0xc9, 0xf9, 0xb9, 0xb9, 0xf9, 0x79, 0xfa, 0xf9,
	0x05, 0x25, 0x99, 0xf9, 0x79, 0xc5, 0x10, 0x29, 0x25, 0x79, 0x2e, 0x5e, 0x1f, 0x57, 0x97, 0x80,
	0xfc, 0xf2, 0xd4, 0xa2, 0xe0, 0x92, 0xc4, 0x92, 0x54, 0x21, 0x3e, 0x2e, 0xa6, 0xfc, 0x3c, 0x09,
	0x46, 0x05, 0x46, 0x0d, 0x8e, 0x20, 0xa6, 0xfc, 0x3c, 0x23, 0x7f, 0x2e, 0x66, 0x1f, 0x57, 0x17,
	0x21, 0x27, 0x2e, 0xde, 0xe0, 0xd4, 0x12, 0x24, 0x75, 0xc2, 0x7a, 0x20, 0x43, 0xf5, 0x50, 0x34,
	0x4b, 0x89, 0xe9, 0x41, 0x9c, 0xa1, 0x07, 0x73, 0x86, 0x9e, 0x2b, 0xc8, 0x19, 0x4a, 0x2c, 0x0d,
	0x5b, 0x25, 0x18, 0xa5, 0x40, 0xa4, 0x40, 0x12, 0x1b, 0x58, 0xce, 0x18, 0x10, 0x00, 0x00, 0xff,
	0xff, 0xe6, 0x65, 0x84, 0xdd, 0xc8, 0x00, 0x00, 0x00,
}

//
// GENERTED FROM tbus/led.proto, DO NOT EDIT
//

// LEDClassID is the class ID of LED
const LEDClassID uint32 = 0x0010

// LEDLogic defines the logic interface
type LEDLogic interface {
    DeviceLogic
    SetPowerState(*LEDPowerState) error
}

// LEDDev is the device
type LEDDev struct {
    DeviceBase
    Logic LEDLogic
}

// NewLEDDev creates a new device
func NewLEDDev(logic LEDLogic) *LEDDev {
    d := &LEDDev{Logic: logic}
    d.Info.ClassId = LEDClassID
    logic.SetDevice(d)
    return d
}

// DispatchMsg implements Device
func (d *LEDDev) DispatchMsg(msg *Msg) (err error) {
    if msg.Head.NeedRoute() {
        return d.Reply(msg.Head.MsgID, nil, ErrRouteNotSupport)
    }
    var reply proto.Message
    switch msg.Body.Flag {
    case 1: // SetPowerState
        params := &LEDPowerState{}
        err = msg.Body.Decode(params)
        if err == nil {
            err = d.Logic.SetPowerState(params)
        }
    default:
        err = ErrInvalidMethod
    }
    return d.Reply(msg.Head.MsgID, reply, err)
}

// SetDeviceID sets device id
func (d *LEDDev) SetDeviceID(id uint32) *LEDDev {
    d.Info.DeviceId = id
    return d
}

// LEDCtl is the device controller
type LEDCtl struct {
    Controller
}

// NewLEDCtl creates controller for LED
func NewLEDCtl(master Master) *LEDCtl {
    c := &LEDCtl{}
    c.Master = master
    return c
}

// SetAddress sets routing address for target device
func (c *LEDCtl) SetAddress(addrs []uint8) *LEDCtl {
    c.Address = addrs
    return c
}

// InvokeLEDSetPowerState represents the invocation of LED.SetPowerState
type InvokeLEDSetPowerState struct {
	MethodInvocation
}

// Timeout implements Invocation
func (i *InvokeLEDSetPowerState) Timeout(dur time.Duration) *InvokeLEDSetPowerState {
	i.Invocation.Timeout(dur)
	return i
}

// Wait waits and retrieves the result
func (i *InvokeLEDSetPowerState) Wait() error {
	return i.Result(nil)
}

// SetPowerState wraps class LED
func (c *LEDCtl) SetPowerState(params *LEDPowerState) *InvokeLEDSetPowerState {
	invoke := &InvokeLEDSetPowerState{}
	invoke.Invocation = c.Invoke(1, params)
	return invoke
}

