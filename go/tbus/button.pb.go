// Code generated by protoc-gen-go.
// source: tbus/button.proto
// DO NOT EDIT!

package tbus

import "time"
import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/golang/protobuf/ptypes/empty"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ButtonState struct {
	Pressed bool `protobuf:"varint,1,opt,name=pressed" json:"pressed,omitempty"`
}

func (m *ButtonState) Reset()                    { *m = ButtonState{} }
func (m *ButtonState) String() string            { return proto.CompactTextString(m) }
func (*ButtonState) ProtoMessage()               {}
func (*ButtonState) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func init() {
	proto.RegisterType((*ButtonState)(nil), "tbus.ButtonState")
}

func init() { proto.RegisterFile("tbus/button.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 183 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xe2, 0x12, 0x2c, 0x49, 0x2a, 0x2d,
	0xd6, 0x4f, 0x2a, 0x2d, 0x29, 0xc9, 0xcf, 0xd3, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x01,
	0x09, 0x49, 0x49, 0xa7, 0xe7, 0xe7, 0xa7, 0xe7, 0xa4, 0xea, 0x83, 0xc5, 0x92, 0x4a, 0xd3, 0xf4,
	0x53, 0x73, 0x0b, 0x4a, 0x2a, 0x21, 0x4a, 0xa4, 0x24, 0xc1, 0xba, 0x92, 0xf3, 0x73, 0x73, 0xf3,
	0xf3, 0xf4, 0xf3, 0x0b, 0x4a, 0x32, 0xf3, 0xf3, 0x8a, 0x21, 0x52, 0x4a, 0xea, 0x5c, 0xdc, 0x4e,
	0x60, 0xd3, 0x82, 0x4b, 0x12, 0x4b, 0x52, 0x85, 0x24, 0xb8, 0xd8, 0x0b, 0x8a, 0x52, 0x8b, 0x8b,
	0x53, 0x53, 0x24, 0x18, 0x15, 0x18, 0x35, 0x38, 0x82, 0x60, 0x5c, 0xa3, 0x0e, 0x46, 0x2e, 0x36,
	0x88, 0x4a, 0x21, 0x6b, 0x2e, 0x0e, 0xf7, 0xd4, 0x12, 0x88, 0x06, 0x31, 0x3d, 0x88, 0xc5, 0x7a,
	0x30, 0x8b, 0xf5, 0x5c, 0x41, 0x16, 0x4b, 0x09, 0xea, 0x81, 0xec, 0xd4, 0x43, 0x32, 0x5b, 0x89,
	0xa5, 0x61, 0xab, 0x04, 0xa3, 0x90, 0x15, 0x17, 0x2b, 0x79, 0x3a, 0x0d, 0x18, 0xa5, 0x58, 0x1b,
	0xb6, 0x4a, 0x34, 0x72, 0x24, 0xb1, 0x81, 0x75, 0x18, 0x03, 0x02, 0x00, 0x00, 0xff, 0xff, 0xb0,
	0xbd, 0x29, 0x59, 0x0d, 0x01, 0x00, 0x00,
}

//
// GENERTED FROM tbus/button.proto, DO NOT EDIT
//

// ButtonClassID is the class ID of Button
const ButtonClassID uint32 = 0x0401

// ButtonLogic defines the logic interface
type ButtonLogic interface {
    DeviceLogic
    GetState() (*ButtonState, error)
}

// ButtonDev is the device
type ButtonDev struct {
    DeviceBase
    Logic ButtonLogic
}

// NewButtonDev creates a new device
func NewButtonDev(logic ButtonLogic) *ButtonDev {
    d := &ButtonDev{Logic: logic}
    d.Info.ClassId = ButtonClassID
    logic.SetDevice(d)
    return d
}

// DispatchMsg implements Device
func (d *ButtonDev) DispatchMsg(msg *Msg) (err error) {
    if msg.Head.NeedRoute() {
        return d.Reply(msg.Head.MsgID, nil, ErrRouteNotSupport)
    }
    var reply proto.Message
    switch msg.Body.Flag {
    case 0:
        devInfo := d.DeviceInfo()
        reply = &devInfo
    case 1: // GetState
        reply, err = d.Logic.GetState()
    default:
        err = ErrInvalidMethod
    }
    return d.Reply(msg.Head.MsgID, reply, err)
}

// SetDeviceID sets device id
func (d *ButtonDev) SetDeviceID(id uint32) *ButtonDev {
    d.Info.DeviceId = id
    return d
}

// ButtonCtl is the device controller
type ButtonCtl struct {
    Controller
}

// NewButtonCtl creates controller for Button
func NewButtonCtl(master Master) *ButtonCtl {
    c := &ButtonCtl{}
    c.Master = master
    return c
}

// SetAddress sets routing address for target device
func (c *ButtonCtl) SetAddress(addrs RouteAddr) *ButtonCtl {
    c.Address = addrs
    return c
}

// InvokeButtonGetState represents the invocation of Button.GetState
type InvokeButtonGetState struct {
	MethodInvocation
}

// Timeout implements Invocation
func (i *InvokeButtonGetState) Timeout(dur time.Duration) *InvokeButtonGetState {
	i.Invocation.Timeout(dur)
	return i
}

// Wait waits and retrieves the result
func (i *InvokeButtonGetState) Wait() (*ButtonState, error) {
	reply := &ButtonState{}
	err := i.Result(reply)
	return reply, err
}

// GetState wraps class Button
func (c *ButtonCtl) GetState() *InvokeButtonGetState {
	invoke := &InvokeButtonGetState{}
	invoke.Invocation = c.Invoke(1, nil)
	return invoke
}

// ChnButtonStateID is the channel index
const ChnButtonStateID uint8 = 1

// ChnButtonState is the subscribed event channel for Button.State
type ChnButtonState struct {
	C chan *ButtonState

	subscription EventSubscription
}

// HandleEvent implements EventHandler
func (c *ChnButtonState) HandleEvent(evt Event, _ EventSubscription) {
	val := &ButtonState{}
	if evt.Decode(val) == nil {
		c.C <- val
	}
}

// Close implement EventSubscription
func (c *ChnButtonState) Close() error {
	close(c.C)
	return c.subscription.Close()
}

// State wraps class Button
func (c *ButtonCtl) State() *ChnButtonState {
	chn := &ChnButtonState{C: make(chan *ButtonState)}
	chn.subscription = c.Subscribe(1, chn)
	return chn
}

